# Journal Entry - 2026-02-05

## Display/System Properties Feature Implementation

### Core Decision/Topic
Implemented the display and system properties query feature (TODO item #4) to allow users to query screen and system input parameters across all supported platforms (macOS, Windows, Linux X11).

### Options Considered
1. **Single unified API with platform-specific fields**: All platforms return the same struct, with optional fields for platform-specific data.
2. **Platform-specific structs**: Different structs per platform with full type safety.
3. **Common core with platform extensions**: Common fields in a base struct, platform-specific data in extension traits.

**Decision**: Chose option 1 (unified API with optional fields) because:
- Simpler API surface for users
- Most use cases only need common fields (bounds, scale_factor)
- `Option<T>` fields clearly indicate platform limitations
- Consistent with the rest of the monio API design

### Final Design

```rust
pub struct DisplayInfo {
    pub id: u32,
    pub bounds: Rect,           // x, y, width, height
    pub scale_factor: f64,      // DPI scale (1.0 = 96 DPI / 1x)
    pub refresh_rate: Option<u32>,  // Hz, not always available
    pub is_primary: bool,
}

pub struct SystemSettings {
    pub keyboard_repeat_rate: Option<u32>,
    pub keyboard_repeat_delay: Option<u32>,
    pub mouse_sensitivity: Option<f64>,
    pub mouse_acceleration: Option<f64>,
    pub mouse_acceleration_threshold: Option<f64>,
    pub double_click_time: Option<u32>,
    pub keyboard_layout: Option<String>,
}
```

### Key Changes Made

| File | Purpose |
|------|---------|
| `src/display.rs` | Public API definitions |
| `src/platform/macos/display.rs` | CoreGraphics-based implementation |
| `src/platform/windows/display.rs` | Win32 API (EnumDisplayMonitors, GetDpiForMonitor) |
| `src/platform/linux/x11/display.rs` | X11 Xlib implementation |
| `src/platform/linux/evdev/display.rs` | Stub returning NotSupported |
| `examples/display.rs` | Demo program |

### Platform-Specific Implementation Notes

**macOS**:
- Uses `CGGetActiveDisplayList` and `CGDisplayBounds` for display enumeration
- Scale factor calculated from `CGDisplayPixelsWide / bounds.width`
- System settings read from `CFPreferencesCopyValue`
- Fixed deprecated API usage (`CGDisplayModeGetRefreshRate` → `CGDisplayMode::refresh_rate`)

**Windows**:
- Uses `EnumDisplayMonitors` for multi-display support
- DPI scale from `GetDpiForMonitor` (falls back to `GetDpiForSystem`)
- Refresh rate from `EnumDisplaySettingsW`
- System parameters via `SystemParametersInfoW`

**Linux X11**:
- Single display support (X11 limitation without RandR extension)
- Pointer control settings via `XGetPointerControl`

**Linux evdev**:
- Returns `NotSupported` error (evdev is for input only, no display info)

### Testing Results
- ✅ macOS: Correctly identifies 2 displays with positions and refresh rates
- ✅ All tests pass (`cargo test`)
- ✅ All examples compile (`cargo check --examples`)

### Future Considerations
1. **Linux X11 RandR extension**: Could add multi-display support for X11
2. **Linux Wayland**: Would need alternative approach (no standard display API)
3. **Keyboard layout**: Currently only implemented for Windows, could add macOS/Linux
4. **macOS keyboard repeat**: Values are in Apple-specific units, may need conversion documentation

---

## Code Review Fixes (Codex Review)

### Core Decision/Topic
Addressed code review feedback from automated Codex review, focusing on robustness issues in the new `recorder` and `statistics` modules.

### Issues Found and Fixed

| Issue | Severity | Fix |
|-------|----------|-----|
| `start_recording` sets `running` flag before `run_async` success | Medium | Reordered: start hook first, then set flag |
| Multiple `lock().unwrap()` may panic on poisoned mutex | Medium | Changed to `lock().map_err()` or `if let Ok()` |
| `clone()` on `Copy` types (`Key`) | Minor | Removed unnecessary `.clone()` calls |
| Collapsible `if` statements | Minor | Used `&& let` chained pattern |
| Scroll direction sign convention undocumented | Low | Added doc comments explaining positive/negative values |

### Key Design Decisions

**1. Mutex Poison Handling**
- **Option A**: Propagate error with `map_err()` (for critical paths like `stop_recording()`)
- **Option B**: Silently ignore with `if let Ok()` (for event callbacks where we can drop events)
- **Option C**: Use `Mutex::into_inner()` to recover data

**Decision**: Used hybrid approach - propagate errors in public API, gracefully handle in callbacks.

**2. Running Flag Ordering**
```rust
// Before (problematic):
self.running.store(true);  // ← Set true here
hook.run_async(...)?;      // ← May fail, flag stays true

// After (fixed):
hook.run_async(...)?;      // ← Start hook first
self.running.store(true);  // ← Only set true on success
```

### Files Modified
- `src/recorder.rs` - Fixed flag ordering, mutex handling
- `src/statistics.rs` - Fixed mutex handling, removed unnecessary clones
- `src/platform/macos/listen.rs` - Collapsed nested if statements
- `src/platform/macos/display.rs` - Removed unnecessary casts

### Verification
```
cargo test --all-features        ✓ 12 passed
cargo clippy --all-features -D warnings  ✓ clean
```

### Future Considerations
1. Consider using `parking_lot::Mutex` for better poison handling
2. Add stress tests for mutex poison recovery
3. Document error handling strategy for contributors
